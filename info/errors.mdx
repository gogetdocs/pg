In PostgreSQL's `PL/pgSQL`, exceptions are handled using the `EXCEPTION` block, where you can catch specific SQLSTATE codes or predefined **exception identifiers**. PostgreSQL provides built-in exception identifiers for common errors to make exception handling easier.

Here is an updated list of **error classes**, **SQLSTATE codes**, and their corresponding **exception identifiers** (where available). If an exception identifier exists, you can use it directly in your `PL/pgSQL` code. Otherwise, you'll need to catch the error using the SQLSTATE code.

### Class 00 — Successful Completion

- `00000`: Successful completion
  - No exception identifier.

### Class 01 — Warning

- `01000`: Warning
- `0100C`: Dynamic result sets returned
- `01008`: Implicit zero-bit padding
- `01003`: Null value eliminated in set function
- `01007`: Privilege not granted
- `01006`: Privilege not revoked
- `01004`: String data right truncation
- `01P01`: Deprecated feature

### Class 02 — No Data

- `02000`: No data
  - Exception identifier: `NO_DATA_FOUND`
- `02001`: No additional dynamic result sets returned

### Class 03 — SQL Statement Not Yet Complete

- `03000`: SQL statement not yet complete

### Class 08 — Connection Exception

- `08000`: Connection exception
- `08003`: Connection does not exist
- `08006`: Connection failure
- `08001`: SQL client unable to establish SQL connection
- `08004`: SQL server rejected establishment of SQL connection
- `08007`: Transaction resolution unknown
- `08P01`: Protocol violation

### Class 09 — Triggered Action Exception

- `09000`: Triggered action exception

### Class 0A — Feature Not Supported

- `0A000`: Feature not supported
  - Exception identifier: `FEATURE_NOT_SUPPORTED`

### Class 0B — Invalid Transaction Initiation

- `0B000`: Invalid transaction initiation

### Class 0F — Locator Exception

- `0F000`: Locator exception
- `0F001`: Invalid locator specification

### Class 0L — Invalid Grantor

- `0L000`: Invalid grantor
- `0LP01`: Invalid grant operation

### Class 0P — Invalid Role Specification

- `0P000`: Invalid role specification

### Class 20 — Case Not Found

- `20000`: Case not found
  - Exception identifier: `CASE_NOT_FOUND`

### Class 21 — Cardinality Violation

- `21000`: Cardinality violation
  - Exception identifier: `CARDINALITY_VIOLATION`

### Class 22 — Data Exception

- `22000`: Data exception
- `2202E`: Array subscript error
- `22021`: Character not in repertoire
- `22008`: Datetime field overflow
- `22012`: Division by zero
  - Exception identifier: `DIVISION_BY_ZERO`
- `22005`: Error in assignment
- `2200B`: Escape character conflict
- `22022`: Indicator overflow
- `22015`: Interval field overflow
- `2201E`: Invalid argument for logarithm
- `22014`: Invalid argument for NTILE function
- `22016`: Invalid argument for NTH_VALUE function
- `2201F`: Invalid argument for power function
- `2201G`: Invalid argument for width_bucket function
- `22018`: Invalid character value for cast
- `22007`: Invalid datetime format
- `22019`: Invalid escape character
- `2200D`: Invalid escape octet
- `22025`: Invalid escape sequence
- `22P06`: Nonstandard use of escape character
- `22010`: Invalid indicator parameter value
- `22023`: Invalid parameter value
- `2201B`: Invalid regular expression
- `22009`: Invalid time zone displacement value
- `2200C`: Invalid use of escape character
- `2200G`: Most specific type mismatch
- `22004`: Null value not allowed
  - Exception identifier: `NULL_VALUE_NOT_ALLOWED`
- `22002`: Null value, no indicator parameter
- `22003`: Numeric value out of range
  - Exception identifier: `NUMERIC_VALUE_OUT_OF_RANGE`
- `22026`: String data length mismatch
- `22001`: String data right truncation
  - Exception identifier: `STRING_DATA_RIGHT_TRUNCATION`
- `22011`: Substring error
- `22027`: Trim error
- `22024`: Unterminated C string
- `2200F`: Zero-length character string
- `22P01`: Floating point exception
- `22P02`: Invalid text representation
- `22P03`: Invalid binary representation
- `22P04`: Bad copy file format
- `22P05`: Untranslatable character
- `2200L`: Not an XML document
- `2200M`: Invalid XML document
- `2200N`: Invalid XML content
- `2200S`: Invalid XML comment
- `2200T`: Invalid XML processing instruction

### Class 23 — Integrity Constraint Violation

- `23000`: Integrity constraint violation
- `23001`: Restrict violation
- `23502`: Not null violation
  - Exception identifier: `NOT_NULL_VIOLATION`
- `23503`: Foreign key violation
  - Exception identifier: `FOREIGN_KEY_VIOLATION`
- `23505`: Unique violation
  - Exception identifier: `UNIQUE_VIOLATION`
- `23514`: Check violation
  - Exception identifier: `CHECK_VIOLATION`
- `23P01`: Exclusion violation

### Class 24 — Invalid Cursor State

- `24000`: Invalid cursor state

### Class 25 — Invalid Transaction State

- `25000`: Invalid transaction state
- `25001`: Active SQL transaction
- `25002`: Branch transaction already active
- `25008`: Held cursor requires same isolation level
- `25003`: Inappropriate access mode for branch transaction
- `25004`: Inappropriate isolation level for branch transaction
- `25005`: No active SQL transaction for branch transaction
- `25006`: Read-only SQL transaction
- `25007`: Schema and data statement mixing not supported
- `25P01`: No active SQL transaction
- `25P02`: In failed SQL transaction

### Class 26 — Invalid SQL Statement Name

- `26000`: Invalid SQL statement name

### Class 27 — Triggered Data Change Violation

- `27000`: Triggered data change violation

### Class 28 — Invalid Authorization Specification

- `28000`: Invalid authorization specification
- `28P01`: Invalid password

### Class 2B — Dependent Privilege Descriptors Still Exist

- `2B000`: Dependent privilege descriptors still exist
- `2BP01`: Dependent objects still exist

### Class 2D — Invalid Transaction Termination

- `2D000`: Invalid transaction termination

### Class 2F — SQL Routine Exception

- `2F000`: SQL routine exception
- `2F005`: Function executed no return statement
- `2F002`: Modifying SQL data not permitted
- `2F003`: Prohibited SQL statement attempted
- `2F004`: Reading SQL data not permitted

### Class 34 — Invalid Cursor Name

- `34000`: Invalid cursor name

### Class 38 — External Routine Exception

- `38000`: External routine exception
- `38001`: Containing SQL not permitted
- `38002`: Modifying SQL data not permitted
- `38003`: Prohibited SQL statement attempted
- `38004`: Reading SQL data not permitted

### Class 39 — External Routine Invocation Exception

- `39000`: External routine invocation exception
- `39001`: Invalid SQL state returned
- `39004`: Null value not allowed
- `39P01`: Trigger protocol violated
- `39P02`: SRF protocol violated

### Class 3B — Savepoint Exception

- `3B000`: Savepoint exception
- `3B001`: Invalid savepoint specification

### Class 3D — Invalid Catalog Name

- `3D000`: Invalid catalog name

### Class 3F — Invalid Schema Name

- `3F000`: Invalid schema name

### Class 40 — Transaction Rollback

- `40000`: Transaction rollback
- `40002`: Transaction integrity constraint violation
- `40001`: Serialization failure
  - Exception identifier: `SERIALIZATION_FAILURE`
- `40003`: Statement completion unknown
- `40P01`: Deadlock detected
  - Exception identifier: `DEADLOCK_DETECTED`

### Class 42 — Syntax Error or Access Rule Violation

- `42000`: Syntax error or access rule violation
- `42601`: Syntax error
  - Exception identifier: `SYNTAX_ERROR`
- `42501`: Insufficient privilege
  - Exception identifier: `INSUFFICIENT_PRIVILEGE`
- `42846`: Cannot coerce
- `42803`: Grouping error
- `42P20`: Windowing error
- `42P19`: Invalid recursion
- `42830`: Invalid foreign key
- `42602`: Invalid name
- `42622`: Name too long
- `42939`: Reserved name
- `42804`: Datatype mismatch
- `42P18`: Indeterminate datatype
- `42P21`: Collation mismatch
- `42P22`: Indeterminate collation
- `42809`: Wrong object type

- `42703`: Undefined column
  - Exception identifier: `UNDEFINED_COLUMN`
- `42883`: Undefined function
  - Exception identifier: `UNDEFINED_FUNCTION`
- `42P01`: Undefined table
  - Exception identifier: `UNDEFINED_TABLE`
- `42P02`: Undefined parameter
- `42704`: Undefined object
  - Exception identifier: `UNDEFINED_OBJECT`
- `42701`: Duplicate column
  - Exception identifier: `DUPLICATE_COLUMN`
- `42P03`: Duplicate cursor
- `42P04`: Duplicate database
- `42723`: Duplicate function
  - Exception identifier: `DUPLICATE_FUNCTION`
- `42P05`: Duplicate prepared statement
- `42P06`: Duplicate schema
- `42P07`: Duplicate table
  - Exception identifier: `DUPLICATE_TABLE`
- `42712`: Duplicate alias
- `42710`: Duplicate object
- `42702`: Ambiguous column
  - Exception identifier: `AMBIGUOUS_COLUMN`
- `42725`: Ambiguous function
  - Exception identifier: `AMBIGUOUS_FUNCTION`

---

In a `PL/pgSQL` block, you can catch these exceptions as follows:

```plpgsql
BEGIN
    -- Your SQL code
EXCEPTION
    WHEN unique_violation THEN
        -- Handle unique violation
        RAISE NOTICE 'Unique violation encountered!';
    WHEN foreign_key_violation THEN
        -- Handle foreign key violation
        RAISE NOTICE 'Foreign key violation encountered!';
    WHEN others THEN
        -- Handle all other exceptions
        RAISE NOTICE 'Other exception encountered!';
END;
```

---

### 1. **Application-Defined Exceptions**

PostgreSQL allows you to define **user-defined exceptions** in your own PL/pgSQL code. These are not pre-defined exceptions in the SQL standard but can be raised using the `RAISE EXCEPTION` statement:

```plpgsql
RAISE EXCEPTION 'Custom error: %', 'something went wrong';
```

You can also associate these custom exceptions with a specific SQLSTATE code:

```plpgsql
RAISE EXCEPTION 'Custom error: %', 'something went wrong' USING ERRCODE = 'P0001';
```

You can catch such exceptions in the `EXCEPTION` block using custom handling logic.

### 2. **Dynamic SQLSTATE Values**

PostgreSQL allows you to **dynamically catch exceptions** based on SQLSTATE values, even if they aren't covered by predefined identifiers. For instance, in your `EXCEPTION` block, you can refer to the SQLSTATE string directly:

```plpgsql
EXCEPTION
    WHEN SQLSTATE '22003' THEN  -- Numeric value out of range
        -- Handle this exception
        RAISE NOTICE 'Numeric value out of range encountered!';
```

This is useful for any SQLSTATE code not directly mapped to an exception identifier or when you want to catch specific non-standard SQL exceptions.

### 3. **Backend and System-Level Exceptions**

PostgreSQL can raise system-level errors during query execution or due to resource limitations (e.g., out of memory, disk full). These exceptions may not always be covered by the SQLSTATE codes provided earlier but will have their own corresponding SQLSTATE codes.

Example: Errors like **"out of memory"**, **"disk space full"**, and **"too many connections"** may result in system-level exceptions that are harder to predict but can be caught in a generic exception handler:

```plpgsql
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'A system error occurred: %', SQLERRM;
```

### 4. **Ad-hoc Exception Handling**

PostgreSQL functions, triggers, and stored procedures often involve ad-hoc, **application-specific conditions** that are not standard. These conditions can be triggered explicitly using `RAISE` statements:

- **RAISE EXCEPTION** for error conditions
- **RAISE WARNING** for less severe warnings
- **RAISE NOTICE** for informational messages
- **RAISE DEBUG** for debugging messages

These do not generate new SQLSTATE codes but are useful for application-specific error handling.

### 5. **Vendor-Specific Extensions and Errors**

PostgreSQL extensions (such as PostGIS, pg_partman, etc.) or third-party extensions may define their own error codes and exceptions. These are extension-specific and not part of the standard SQLSTATE list, so they may introduce new errors that are only relevant when those extensions are being used.

For example, **PostGIS** might raise errors like:

- Geometry-related errors (`XX000` or custom SQLSTATE codes)
- Projection-related issues in spatial data

Catching such errors often requires knowing the extensions' SQLSTATE codes or catching them with a generic exception handler.

---

### Catching All Remaining Exceptions

You can always include a generic handler for any exceptions not explicitly covered:

```plpgsql
BEGIN
    -- Your SQL code
EXCEPTION
    WHEN OTHERS THEN
        -- Handle any unanticipated exceptions
        RAISE NOTICE 'An unexpected error occurred: SQLSTATE = %, Message = %', SQLSTATE, SQLERRM;
END;
```

This will catch **any exception**, print out the SQLSTATE code, and the accompanying error message.

### Conclusion

While the list I provided earlier covers **most common and standard errors** in PostgreSQL, there are additional exception categories such as:
